## 1.7. Programming Paradigms Overview

A mathematician views a program as a function that can be decomposed (divided) into simpler functions so that the program-function is their superposition. That is, roughly speaking, a program is a complex formula, a data transformer, where the problem conditions are fed as input, and we get the solution as output. Not every programmer is familiar with this point of view, though it's not perfect, it's useful for rethinking one's activities. The opposite point of view is more common, which is easily obtained from programming practice. It consists of writing programs based on the user's representation, from user interface screen designs and from tools, language, platform, and libraries. As a result, we get not a program-function, but a large system of states in which a combinatorial explosion of transitions occurs and whose behavior is unpredictable even for the author, let alone the user. But we cannot immediately reject this seemingly terrible approach. It has a constructive core, and it lies in the fact that not all programs can be implemented in the functional paradigm as data transformers in a short time. Moreover, human activity consists entirely of steps and changes in the states of objects around us according to the principle of step-by-step manipulation of them, and representing it as functions would be quite unnatural for our thinking.

A paradigm sets a set of ideas and concepts, assumptions and constraints, concepts, principles, postulates, techniques and programming techniques for solving problems on a computer.

In this section, we will consider some of them superficially, and later in the book there will be a special chapter with a more detailed discussion of each paradigm. There are languages that support one paradigm, and there are multi-paradigm languages. We will pay attention to different languages and differences in the implementation of paradigms in them.

For a person, it is natural to represent any action as a set of steps or an algorithm - this is the imperative approach. These steps can be either linear or making a decision to move to another step of the plan, instead of executing actions sequentially. Making a decision for a machine is a comparison operation that leads to algorithm branching, giving options (usually two). Actions can be conditionally divided into internal and external. In internal ones, only the processor and memory participate, the action is executed immediately, without waiting, and has a certain result that is available directly at the next step of the algorithm. External actions are calls to external input/output devices (network, disks, other devices), and they require waiting for a response from the device, which will come in a time usually unknown in advance. We send a control signal to peripheral devices about what they need to do and transfer the necessary data to them. Further, we have two options again: either wait for the result, and this will be called blocking input/output mode, or move to the next step of the algorithm without waiting for the result, and this will be non-blocking input/output. Such a division is caused by a significant difference in the duration of internal and external actions. Most external actions are associated with physical operations on the external environment. For example, data transmission over wireless or wired networks, writing or reading from a physical medium, interaction with sensors, relays or actuators. Such operations often have not a digital, but an analog nature, so additional data conversion is required, waiting for a transient process, waiting for the required sensor reading or signal from the device, etc. Input/output devices often have their own controller in which a separate stream of operations is executed, and interaction between the central processor and input/output devices also requires coordination, which takes time and can end unsuccessfully.

A paradigm offers a generalized model for solving problems, a certain style, patterns, examples of good and bad solutions used for writing program code.
