# 1. Introduction

Constant rethinking of one's activities, even the simplest ones, should accompany an engineer throughout their life. The habit of writing down one's thoughts in words and refining formulations is very helpful in this regard. This text emerged as my fragmentary notes, written in different years, which I accumulated and critically reviewed dozens of times. Often, I disagreed with myself when re-reading a passage after it had been sitting for some time. Therefore, I refined the text until I agreed with what was written after prolonged periods of material maturation. I set myself the task of writing as concisely as possible and repeatedly rewrote large fragments, finding that they could be expressed more briefly. The structure of the text and table of contents began to emerge after the first year of teaching, but in the tenth year I decided to publish all materials not only as open video lectures, as I had been doing for about five years, but also as text. This allowed everyone from the Metarchy community to participate in shaping the book, quickly find typos and inaccuracies thanks to readers, and for many it's simply more convenient to perceive in book form. The current version can always be found at https://github.com/HowProgrammingWorks/Book, it will be continuously updated. Please send requests for corrections and additions to issues: https://github.com/HowProgrammingWorks/Book/issues in English, new ideas to discussions: https://github.com/HowProgrammingWorks/Book/discussions in any language, and format your additions and corrections as pull-requests to the book repository.

> Programming is the art and engineering of solving problems using computational technology

Engineering, because it is designed to extract benefit from knowledge, and art, because programming at the current stage of development, unfortunately, is not limited to knowledge and is forced to resort to intuition and poorly understood personal experience. The programmer's task is not to find a mathematically correct solution, but to find a generalized solution mechanism capable of leading us to finding an acceptable solution in limited time for as large a class of problems as possible. In other words, to find an abstract class of solutions. Not all programming paradigms assume step-by-step solutions, but the physical implementation of computational technology and the nature of human thinking assume step-by-step processes. The complexity lies in the fact that these actions are far from always reducible to machine operations and involve external interaction with input/output devices and sensors, and through them, with the external world and humans. This circumstance creates great uncertainty, which does not allow mathematically rigorous proof of the correctness of the method for solving all problems and, moreover, strictly derive such a solution from axioms, as is characteristic of exact sciences. However, individual algorithms can and should be derived analytically if they are reducible to pure functions. That is, to functions that at any moment for a certain set of input data unambiguously give the same result. A pure function has no history (memory or state) and does not access external devices (which may have such state), can only access other pure functions. Programming inherited from mathematics the ability to find exact solutions analytically, and the computational machine itself functions strictly within the framework of formal mathematical apparatus. But the process of writing program code cannot always be reduced to formal procedures, we are forced to make decisions under conditions of great uncertainty and construct programs engineering-wise. The programmer is limited by the time of program development, so we reduce uncertainty by introducing constructive constraints that are not strictly derivable from the task and are based on the intuition and experience of a particular specialist. Simply put, in the absence of an optimal algorithm, a programmer can solve a problem in any way that gives acceptable results in reasonable time, and which can be implemented in such time while the problem remains relevant. Under such conditions, we must take into account not only the measure of approximation of the solution to the optimal one, but also the programmer's knowledge, mastery of tools, and other available resources. After all, even access to knowledge of ready-made software solutions is limited by copyright, source code ownership rights and documentation, corresponding license restrictions, not only for software products, but also for books, videos, articles, educational materials, etc. All this significantly complicates and slows down the development of the industry, but over time the availability of knowledge irreversibly grows, they seep into free circulation on the network through popularizers, enthusiasts and the free software movement.
