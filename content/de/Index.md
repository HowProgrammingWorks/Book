# Inhaltsverzeichnis

1. **Einführung**  
   1.1. Lernansätze beim Programmieren  
   1.2. Beispiele in JavaScript, Python und C  
   1.3. Modellierung: Abstraktionen und Wiederverwendung  
   1.4. Algorithmus, Programm, Syntax, Sprache  
   1.5. Dekomposition und _Separation of Concerns_  
   1.6. Überblick über den Beruf Softwareingenieur  
   1.7. Überblick über Programmierparadigmen

2. **Grundkonzepte**  
   2.1. Wert, Bezeichner, Variable und Konstante, Literal, Zuweisung  
   2.2. Datentypen: skalare, Referenz- und strukturierte Typen  
   2.3. Operator und Ausdruck, Codeblock, Funktion, Schleife, Bedingung  
   2.4. Kontexte und lexikalischer Scope  
   2.5. Prozedurales Paradigma, Aufruf, Stack und Heap  
   2.6. Höhere Funktionen, reine Funktionen, Seiteneffekte  
   2.7. Closures, Callbacks, Wrapper und Events  
   2.8. Ausnahmen und Fehlerbehandlung  
   2.9. Praxisaufgaben zum Abschnitt

3. **Zustände, Datenstrukturen und Sammlungen**  
   3.1. Stateful- und Stateless-Ansatz  
   3.2. Strukturen und Records  
   3.3. Array, Liste, Set, Tupel  
   3.4. Dictionary, Hashtabelle und assoziatives Array  
   3.5. Stack, Queue, Deque  
   3.6. Bäume und Graphen  
   3.7. Projektion von Datenmengen  
   3.8. Analyse der Zeit- und Speicherkomplexität

4. **Erweiterte Konzepte**  
   4.1. Was ist ein Technologiestack?  
   4.2. Entwicklungsumgebung und Debugging  
   4.3. Iteration: Rekursion, Iteratoren und Generatoren  
   4.4. Bausteine einer Anwendung: Dateien, Module, Komponenten  
   4.5. Objekt, Prototyp und Klasse  
   4.6. Partielle Anwendung und Currying, _Pipe_ und _Compose_  
   4.7. Chaining von Methoden und Funktionen  
   4.8. Mixins  
   4.9. Abhängigkeiten und Bibliotheken

5. **Verbreitete Programmierparadigmen**  
   5.1. Imperativer und deklarativer Ansatz  
   5.2. Strukturierte und unstrukturierte Programmierung  
   5.3. Prozedurale Programmierung  
   5.4. Funktionale Programmierung  
   5.5. Objektorientierte Programmierung  
   5.6. Prototypenbasierte Programmierung

6. **Antipatterns**  
   6.1. Allgemeine Antipatterns für alle Paradigmen  
   6.2. Prozedurale Antipatterns  
   6.3. Objektorientierte Antipatterns  
   6.4. Funktionale Antipatterns

7. **Entwicklungsprozess**  
   7.1. Softwarelebenszyklus, Domänenanalyse  
   7.2. Konventionen und Standards  
   7.3. Tests: Unit Tests, System- und Integrationstests  
   7.4. Code-Review und Refactoring  
   7.5. Ressourcenabschätzung, Plan und Zeitplan  
   7.6. Risikoanalyse, Schwachstellen, nicht-funktionale Anforderungen  
   7.7. Koordination und Prozessanpassung  
   7.8. Continuous Deployment und Continuous Delivery  
   7.9. Multidimensionale Optimierung

8. **Fortgeschrittene Konzepte**  
   8.1. Events, Timer und _EventEmitter_  
   8.2. Introspektion und Reflexion  
   8.3. Serialisierung und Deserialisierung  
   8.4. Reguläre Ausdrücke  
   8.5. Memoisierung  
   8.6. Factory und Pool  
   8.7. Typisierte Arrays  
   8.8. Projektionen  
   8.9. I/O und Dateien

9. **Architektur**  
   9.1. Dekomposition, Benennung und Verknüpfung  
   9.2. Interaktion zwischen Softwarekomponenten  
   9.3. Kopplung über Namensräume  
   9.4. Interaktion mit Funktionsaufrufen und Callbacks  
   9.5. Interaktion mit Events und Nachrichten  
   9.6. Schnittstellen, Protokolle und Verträge  
   9.7. Onion-Architektur bzw. Schichtenarchitektur

10. **Grundlagen paralleler Berechnungen**  
    10.1. Asynchrones Programmieren  
    10.2. Paralleles Programmieren, gemeinsamer Speicher (Shared Memory) und Synchronisationsprimitive  
    10.3. Asynchrone Primitives: Thenable, Promise, Future, Deferred  
    10.4. Coroutinen, Goroutinen, async/await  
    10.5. Adapter zwischen asynchronen Verträgen  
    10.6. Asynchrone und parallele Interoperabilität  
    10.7. Nachrichtenbasierter Ansatz und Actor-Modell  
    10.8. Asynchrone Warteschlangen und Sammlungen  
    10.9. lockfreie Datenstrukturen

11. **Erweiterte Programmierparadigmen**  
    11.1. Generische Programmierung  
    11.2. Ereignisgesteuerte und reaktive Programmierung  
    11.3. Automatenbasierte Programmierung und Zustandsmaschinen  
    11.4. Domänenspezifische Sprachen (DSLs)  
    11.5. Datenflussprogrammierung  
    11.6. Metaprogrammierung  
    11.7. Dynamische Interpretation von Metamodellen

12. **Datenbanken und persistente Speicherung**  
    12.1. Geschichte der Datenbanken und Navigational Databases  
    12.2. Key-Value Stores und andere abstrakte Datenstrukturen  
    12.3. Relationales Datenmodell und ER-Diagramme  
    12.4. Schemalose, objektorientierte und dokumentenbasierte Datenbanken  
    12.5. Hierarchische und Graphdatenbanken  
    12.6. Spaltenorientierte und In-Memory-Datenbanken  
    12.7. Verteilte Datenbanken

13. **Verteilte Systeme**  
    13.1. Interprozesskommunikation  
    13.2. Konfliktfreie replizierte Datentypen (CRDTs)  
    13.3. Konsistenz, Verfügbarkeit und Partitionierung  
    13.4. Konfliktlösungsstrategien  
    13.5. Konsensprotokolle  
    13.6. CQRS, Event Sourcing
