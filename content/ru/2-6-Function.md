## 2.6. Функция высшего порядка, чистая функция, побочные эффекты

Объявление функции (Function definition) — в `JavaScript` это способ объявления функции, который виден из любого места в лексическом контексте, в котором объявлена функция, пример: `function sum(a, b) { return a + b; }`

Функциональное выражение (Function expression) — связывание функции с идентификатором при помощи присвоения, при котором значение будет доступно через идентификатор не во всем лексическом контексте, а только после места присвоения. Имеет несколько синтаксических вариантов:

Функциональное выражение с именованной функцией (Named function expression): `const max = function max(a, b) { return a + b; };`

Анонимное функциональное выражение (Anonymous function expression): `const max = function(a, b) { return a + b; };`

Стрелочная или лямбда-функция (Arrow, Lambda function): `const max = (a, b) => { return a + b; };`

Лямбда-выражение, Функция-стрелка с выражением в качестве тела (Lambda expression, Arrow function): `const max = (a, b) => (a + b);`

> Чистая функция (Pure Function) — детерминированная функция без побочных эфектов.

Чистая функция, вычисляющая результат только на основе аргументов, не имеющая состояния и не обращающаяся к операциям ввода-вывода. Результат чистой функции всегда детерминированный, т.е. для любого аргумента всегда будет один и тот же результат. Чистая функция не имеет побочных эффектов (см. побочный эффект).

> Замыкание (Closure) — функция, связанная с лексическим окружением в момент своего создания.

Если вернуть функцию `g` из функции `f`, то `g` будет видеть контекст функции `f`, так же, как и свои аргументы. Если `f` возвращает `g`, то говорят, что экземпляр `g` замкнул контекст `f`. Замыкание — это способ, позволяющий связать функцию с контекстом (с данными или переменными контекста). Замыкание позволяет создать эффект, аналогичный состоянию объекта (набору его свойств) в ООП. Свойства связаны с методами через объект, по сути объект в ООП сам является контекстом связывания. Замыкание так же порождает подобный контекст, но на основе функций первого класса и лексического контекста, а не объектного.

При помощи замыкания можно реализовать функциональное наследование.

Примеры:

```js
const add = (a) => (b) => a + b;

const hash =
  (data = {}) =>
  (key, value) => ((data[key] = value), data);
```

> Суперпозиция (Superposition) — объединение вызова функций в выражения таким образом, что результат одних функций становится аргументами других функций.

```js
const expr2 = add(pow(mul(5, 8), 2), div(inc(sqrt(20)), log(2, 7)));
```

> Композиция (Composition) — создание новой функции объединением более простых.

```js
const compose = (f1, f2) => (x) => f2(f1(x));
```

```js
const compose =
  (...funcs) =>
  (...args) =>
    funcs.reduce((args, fn) => [fn(...args)], args);
```

> Частичное применение (Partial application)

```js
const partial =
  (fn, x) =>
  (...args) =>
    fn(x, ...args);
```

> Каррирование (Currying)

```js
const result = curry((a, b, c) => a + b + c)(1, 2)(3);
```

> Побочные эффекты (Side effects)

> Функция высшего порядка (Higher-order Function)

1. Если функция передается в другую функцию в качестве аргумента, то это колбек.
2. Если функция фозвращается в качестве результата, то это фабрика функций на замыканиях.
3. Если возвращаемая функция имеет ту же семантику, что и получаемая в аргументах, но с дополнительным (расширенным) поведением, то это функция-обертка.
4. Редко бывает, что возвращаемая функция не связана с функцией из аргументов, или связана не прямо, а так же имеет другую семантику и функцией-оберткой она не является.
5. Если на выходе класс или функция-конструктор, то это фабрики классов и прототипов соответственно.

> Функция-обертка (Wrapper)

Функция, которая оборачивает другую функцию (иногда объект, интерфейс или функциональный объект), добавляя ему дополнительное поведение. Можно обернуть целый API интерфейс и даже асинхронную функцию вместе с колбеками (если известен контракт).
