## 2.1. Значение, идентификатор, переменная и константа, литерал, присвоение

> Идентификатор (identifier)

Самое важное в программировании — это давать понятные _имена_ идентификаторам (переменным, константам, параметрам, функциям, классам и т.д.) и располагать их в программе так, чтобы они были _видны_ в нужных местах. При этом нужно стараться сократить их _область видимости_. Идентификаторы могут быть глобальными, объявленными внутри файла или импортированными из других модулей программы.

Есть разные конвенции (договоренности) о именовании, традиции языков и парадигм, но во всех них имена должны быть _консистентные_ (однотипные) и _понятные_ даже для тех, кто код этот не писал. Примеры хороших имен идентификаторов:

- Глобальные переменные: `MAX_PURCHASE`, `REQUEST_TIMEOUT`, `ERROR_CODES`
- Коллекции: `prices`, `goods`, `boughtItems`
- Отдельные значения: `amount`, `groupName`, `total`
- Функции: `calculateSubtotal`, `calculateTotal`, `validateExpenses`

Примеры плохих имен рассмотрим подробнее:
- Глобальная константа `Maximum` - не понятно, максимум чего, без второго слова константа не может быть глобальной; нарушены конвенции использования строчных и заглавных букв, вместо `camelCase` тут использован `PascalCase` и такую константу сложно заметить при чтении кода;
- Таймаут запросов `request_timeout` - нарушены конвенции;
- Коды ошибок `ERCODE` - сложно читается; не понятно, что это коллекция кодов, а не один код;
- Массив цен `numbers` - не нужно называть массивы именами типов данных, которые в них находятся, из этого названия очень сложно понять, что там цены;
- Массив товаров `arrayOfGoods` - не добавляйте названия структур данных в имена переменных;
- Слишком длинное имя для коллекции товаров: `orderItemsInShopBasket`;
- Неочевидное сокращение `amt`;
- Кроме явного нарушения концепций `grp_N` еще и вводит в заблуждение, это плохое сокращение, не нужно экономить на буквах до такой степени;
- Не называйте переменные транслитом, как `itogo2` и не используйте цифры для именования переменных с похожим смыслом, попробуйте учесть оттенки смысла, например: `total` и `subtotal`;
- Если структура содержит два значения, как `tolalAndSubtotal`, то нужно назвать ее таким словом, которое обобщает их, например `order`;
- Кроме нарушения конвенций `BuyerCalculations` еще и очень не точный, не понятно, какие именно вычисления;
- Короткие сокращения типа `VE` - совершенно неприемлимы в качестве имен, если только это не общепринятые `i` и `j` для циклов или, `x` и `y` для координат и еще несколько подобных случаев.

> Объявление и присвоение (assignment)

```js
let migrationYear = 622;
```

Эта запись на JavaScript и тут `migrationYear` — имя идентификатора, `=` это оператор присвоения, `622` — значение, а `let` означает, что значение может быть переприсвоено, т.е. изменено.

В C и C++ аналогичный код будет выглядеть так:

```c
int migrationYear = 622; // тут тип int представляет целое число
```

В Python, как и в JavaScript, оператор присвоения не требует указывать тип, он определяется из типа литерала. А при присвоении, мы не можем запретить переприсвоить идентификатору другое значение.

```py
migrationYear = 622
```

Операция присвоения во многих языках возвращает присваиваемое значение (имеет поведение выражения). Таким образом, можно написать

```js
let year;
const migration = (year = 622); // теперь оба идентификатора
console.log({ migration, year }); // имеют значение 622
```

Но такой синтаксис плохо читается и может ввести в заблуждение, как и задание нескольких идентификаторов через запятую:

```
let year = 622, migration = 'Hijrah', i, counter = 0;
```

Экономия в коде это хорошо, но не экономьте буквы и строки за счет читабельности кода. Вместо этого лучше написать:

```js
let year = 622;
let migration = 'Hijrah';
let i;
let counter = 0;
```

А еще лучше сразу решить, какие идентификаторы не будут менять свое значение и задать их через `const`:

```js
const year = 622;
const migration = 'Hijrah';
let i;
let counter = 0;
```

> Переменные и константы

В повседневном общении даже профессионалы часто путают понятия, называя константу переменной, ведь слово `идентификатор` слишком длинное, а слово `константа` слишком многозначное. Это случается с локальными константами, которые мы называем в стиле `lowerCamel`, например внутри функций. Их значение может быть разным при разных вызовах функции, а есть глобальные, значение которых одинаково в любом месте программы или файла, и мы называем их в стиле `UPPER_SNAKE`.

```js
const WATCH_TIMEOUT = 5000; // Глобальная константа
```

```js
const cityName = 'Beijing'; // Локальная константа
```

```js
let distance = 0; // Переменная
```

Мы можем менять значение переменной в отличие от константы, а для некоторых языков, как JavaScript и Python, можем менять и тип, но это будет сильно ухудшать читаемость кода, например:

```js
let migration = 'Hijrah'; // используем переменную первый раз
console.log(migration); // вывод строки
migration = 622; // используем повторно для других целей
console.log(migration); // вывод числа
```

> Литерал (Literal) — запись значения в коде программы

Идентификаторы связываются со своими _значениями_ в памяти во время работы программы, но во время написания кода мы иногда хотим задавать значения синтаксически (т.е. записывать их символами в правилах конкретного языка программирования). Например: литерал числа и строки, литерал объекта и массива, даже литерал функции и класса (но их мы увидим в следующих главах). В разных языках разные правила записи литералов, но они частично совпадают и обычно их не сложно прочитать. Литералы могут задавать не только значение, а тип и систему счисления при помощи префиксов и суффиксов. Давайте посмотрим примеры:

- Строка `it's`: в одинарных кавычках `'it\'s'`, тут символ бэкслеш `\`  позволяет использовать кавычку внутри строки; в двойных `"it's"`, тут `\` не нужен, но может использоваться для двойной кавычки внутри строки и других символов;
- Целое число `255` можно записать, как `0xFF` в шестнадцатеричной системе; `0o377` в восьмеричной; а вот запись `0377` это старая форма, она не поддерживается в Python начиная с 3 версии, а в JavaScript работает, но плохо читается; `0b11111111` в бинарной записи; литерал `255n` с суффиксом `n` в JavaScript создает значение типа BigInt; а `255u`; `255l`, `255ul` в C++ и ряде других языков, где суффикс `u` (unsigned) и задает беззнаковый тип, а суффикс `l` (long) задает длинное число;
- Дробное число `1.618` записывается: `1.618`; в C++ и Java `1.618f` число с плавающей точкой; и `1.618d` число с двойной точностью, а `1618e-3` в экспоненциальной форме;
- Число `-12000`, кроме обычной записи, может еще быть записано: `-12000n`; `-1.2e4`; `-12e3`; `-12e3f`; `-1.2e4d`; тут символы `n`, `f` и `d` обозначают тип, а `e` экспоненциальную форму;  в разных языках поддерживаются разные формы записи;
- Булевы литералы: `true` и `false`;
- Литерал массива: `[1, 2, 3]` в JavaScript и Python; в C и C++, Java, C# `{ 1, 2, 3, 4 }`;
- Литерал словаря: `{ 'uno': 1, 'due': 2, 'tre': 3 }` в Python; и литерал объекта `{ uno: 1, due: 2, tre: 3 }` в JavaScript;

Эта книга не является руководством по какому-либо языку, а особенности конкретного языка можно узнать из его спецификации, учебника или из примеров кода, которых тут достаточно, чтобы освоить запись всех необходимых литералов JavaScript и Python.

> Пример программы

Тут многие конструкции знакомы, но есть и новые (функция, цикл, условие), они будут подробнее рассмотрены в следующих разделах, хотя их простое использование не сложно прочитать и понять уже сейчас.

```js
'use strict';

const MAX_PURCHASE = 2000; // глобальная константа

// Функция вычисления суммы покупок из массива цен
// prices - параметр (массив цен)
const calculateTotal = (prices) => {
  // Задаем переменную с начальным значением
  let amount = 0; // Перебираем элементы массива в цикле
  for (const price of prices) {
    // локальная константа price не меняется в цикле
    // на каждом проходе добавляем к сумме
    amount += price;
  }
  return amount; // возвращаем сумму из функции
};

// Задаем массив цен товаров
const purchase = [1500, 100, 10, 50];
// Вызываем функцию вычисления суммы и передаем ей аргумент
// Из функции значение аргумента будет доступно через параметр
const total = calculateTotal(purchase);
// Результат записываем в локальную константу
// Если сумма не превысила максимальную, то выводим ее
if (total <= MAX_PURCHASE) {
  console.log({ total }); // Выводит: { total: 1660 }
}
```
