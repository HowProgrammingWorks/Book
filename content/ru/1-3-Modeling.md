## 1.3. Моделирование: абстракции и повторное использование

В основе любого программирования, лежит моделирование, то есть, создание модели решения задачи или модели объектов и процессов в памяти машины. Языки программирования предоставляют синтаксисы для конструирования ограничений при создании моделей. Любая конструкция и структура, призванная расширить функциональность и введенная в модель, приводит к дополнительным ограничениям. Повышение же уровня абстракции, наоборот, может снимать часть ограничений и уменьшать сложность модели и кода программы, выражающего эту модель. Мы все время балансируем между расширением функций и сверткой их в более обобщенную модель. Этот процесс может и должен быть многократно итеративным.

Удивительно, но человек способен успешно решать задачи, сложность которых превышает возможности его памяти и мышления, при помощи построения моделей и абстракций. Точность этих моделей определяет их пользу для принятия решений и выработки управляющих воздействий. Модель всегда не точна и отображает только малую часть реальности, одну или несколько ее сторон или аспектов. Однако, в ограниченных условиях использования, модель может быть неотличимой от реального объекта предметной области. Есть физические, математические, имитационные и другие модели, но нас будут интересовать, в первую очередь, информационные и алгоритмические модели.

Абстракция, это способ обобщения, сводящий множество различных, но схожих между собой случаев, к одной модели. Нас интересуют абстракции данных и абстрактные алгоритмы. Самые простые примеры абстракции в алгоритмах, это циклы (итерационное обобщение) и функции (процедуры и подпрограммы). При помощи цикла мы можем описать множество итераций одним блоком команд, предполагая его повторяемость несколько раз, с разными значениями переменных. Функции так же повторяются много раз с разными аргументами. Примеры абстракции данных, это массивы, ассоциативные массивы, списоки, множества и т.д. В приложениях абстракции нужно объединять в уровни — слои абстракций. Низкоуровневые абстракции встроены в язык программирования (переменные, функции, массивы, события). Абстракции более высокого уровня содержатся в программных платформах, рантаймах, стандартных библиотеках, и внешних библиотеках или их можно построить самостоятельно из простых абстракций. Абстракции так называются, потому, что решают абстрактные обобщенные задачи общего назначения, не связанные с предметной областью.

Построение слоев абстракций это чуть ли не самая важная задача программирования от удачного решения которой зависят такие характеристики программного решения, как гибкость настройки, простота модификации, способность к интеграции с другими системами и период жизни решения. Все слои, которые не привязаны к предметной области и конкретным прикладным задачам, мы будем называть системными. Над системными слоями программист надстраивает прикладные слои, абстракция которых наоборот снижается, универсальность уменьшается и конкретизируется применение, привязываясь к конкретным задачам.

Абстракции разных уровней могут находиться как в одном адресном пространстве (одном процессе или одном приложении), так и в разных. Отделить их один от другого и осуществить взаимодействие между ними можно при помощи программных интерфейсов, модульности, компонентного подхода и просто усилием воли, избегая прямых вызовов из середины одного программного компонента в середину другого, если язык программирования или используемая платформа не заботятся о предотвращении такой возможности. Так следует поступать даже внутри одного процесса, где можно было бы обращаться к любым функциям, компонентам и модулям из любых других, даже если они логически относятся к разным слоям. Причина этого в необходимости понизить связанность слоев и программных компонентов, обеспечив их взаимозаменяемость, повторное использование и делая возможной их раздельную разработку. Одновременно нужно повышать связность внутри слоев, компонентов и модулей, что обеспечивает рост производительности кода, простоту его чтения, понимания и модификации. Если же нам удастся избегать связанности между разными уровнями абстракций, и при помощи декомпозиции добиться того, чтобы один модуль всегда мог быть полностью охвачен вниманием одного инженера, то процесс разработки становится масштабируемым, управляемым и более предсказуемым. Подобная идея положена в основу архитектуры микросервисов, но более общий принцип применим для любых систем, и не важно, будут ли это независимо запущенные микросервисы или модули, запущенные в одном процессе.

Нужно отметить, что чем лучше система распределена, тем лучше она централизована. Потому, как решения задач в таких системах находятся на адекватных уровнях, где уже достаточно информации для принятия решений, обработки и получения результата, отсутствует жесткая связанность моделей разного уровня абстракции. При таком подходе не происходит излишних эскалаций задачи на верхние уровни, избегаются “перегревы” узлов принятия решений, минимизирована передача данных и повышено оперативное быстродействие.
