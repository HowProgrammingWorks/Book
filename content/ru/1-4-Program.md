## 1.4. Алгоритм, программа, синтаксис, язык

Есть много терминов, связанных с программированием. Для определенности нам следует выяснить разницу между ними. Лучше сосредоточиться на неформальном понимании, чем на формальном определении. Самым старым понятием тут является алгоритм, который мы все помним из школьного курса математики. Например, алгоритм Евклида для нахождения наибольшего общего делителя двух целых чисел.

> Алгоритм (Algorithm)

Алгоритм это еще не программа, это идея решения задачи, описанная формально. Так, чтобы она была понятна другим, проверяема и реализуема. Алгоритм нельзя запустить, его можно преобразовать в код на каком-то языке программирования. Алгоритм содержит описание операций и может быть записан разными способами: формулой, блок-схемой, списком действий на человеческом языке. Он всегда ограничен конкретным классом задач, которые он решает за конечное время. Часто мы можем упростить и оптимизировать алгоритм, сузив класс задач. Например, переходя от вычисления суммы целых и дробных чисел к вычислению суммы только целых, мы можем сделать более эффективную реализацию. Можно и расширить класс задач для этого примера, разрешив подавать на вход еще и строчные представления чисел. Это сделает алгоритм более универсальным, но менее эффективным. Мы должны выбирать, что именно мы оптимизируем. В данном случае лучше разделить алгоритм на два, один будет приводить все числа к одному типу данных, а второй складывать.

> Пример реализации алгоритма НОД (GCD)

На `JavaScript` алгоритм Евклида, для нахождение НОД (общей меры или наибольшего общего делителя) можно написать так:

```js
const gcd = (a, b) => {
  if (b === 0) return a;
  return gcd(b, a % b);
};
```

Или даже короче, но станет не менее понятно, если вы сравните два эти варианта и проследите какие конструкции заменены:

```js
const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
```

Этот простой алгоритм является рекурсивным, т.е. обращается к самому себе для вычисления следующего шага и предусматривает выход, когда `b` доходит до `0`. Для алгоритмов мы можем определять вычислительную сложность, классифицировать их по ресурсам процессорного времени и памяти, необходимым для решения задачи.

> Программа (Program)

В предыдущем примере мы имели дело с функцией, это часть программы, но чтобы она заработала, ее нужно вызвать и передать ей данные. Программный код и данные, объединенные в одно целое, это и есть программа. У Никлауса Вирта, автора многих языков, в том числе и Pascal, есть книга «Алгоритмы + Структуры данных = Программы». Ее название схватило очень важную истину, которая глубоко запечатлилась не только в мировоззрении читателей, но и в названиях курсов в ведущих ВУЗах, и даже на собеседованиях, когда испытуемого просят сконцентрироваться именно на этих двух вещах. За первые 50 лет существования индустрии программного обеспечения, оказалось, что структуры данных не менее важны, чем алгоритмы. Более того, многие известные программисты делают на них основную ставку, например, известна цитата Линуса Торвальдса: «Плохие программисты беспокоятся о коде. Хорошие программисты беспокоятся о структурах данных и связях между ними». Дело в том, что выбор структур данных во многом предопределяет то, каким будет алгоритм, ограничивает его в рамках вычислительной сложности и семантики задачи, которую программист понимает через данные, разложенные в памяти, гораздо лучше, чем через последовательность операций.

Эрик Рэймонд выразил это так: «Умные структуры данных и тупой код работают куда лучше, чем наоборот».

> Код позволяет найти общий язык

Однако, тот же Линус Торвальдс сказал нам еще и «Болтовня ничего не стоит. Покажите мне код». Это совсем не противоречит сказанному выше. Я думаю, что тут он имел в виду то, что программный код не допускает двусмысленности. Это универсальный язык, который позволяет программистам находить общий язык даже тогда, когда естественные языки, из-за своей многозначности не позволяют точно понять друг друга, можно сделать это просто взглянув на код.

> Инженерия (Engineering)

Извлечение практической пользы из имеющихся ресурсов при помощи науки, техники, различных методик, организационной структуры, приемов и знаний это следующий уровень — инженерия.

Я помню, что в первые годы изучения программирования для меня уже было важно, чтобы код использовался людьми, улучшал их жизнь и сам жил долго. Олимпиадные задачи казались мне неинтересными, учебные задачи слишком надуманными, хотелось сконцентрироваться на том, что люди будут запускать на своих компьютерах каждый день: приложения баз данных, формы и таблицы, сетевые и коммуникационные приложения, программы, управляющие аппаратурой, работающие с датчиками, и множество инструментов для самих программистов.

Так же, как и в других инженерных отраслях, в программировании очень важна польза для человека, а не правильность и или стройность концепции. Инженерия призвана использовать научные достижения, а в тех местах, где научных знаний, имеющихся на сегодня, недостаточно, инженерия применяет интуицию, инженерную культуру, метод проб и ошибок, применение неосознанного опыта и опыта, имеющего недостаточное научное осмысление.

В этом и преимущество инженерии и недостаток. Мы имеем множество разных и противоречивых решений одной задачи, мы не всегда знаем почему что-то не работает, но это еще ладно, мы иногда удивляемся, почему что-то работает. Такой подход приводит к накоплению плохих практик в проектах и такому переплетению хороших и плохих практик, что разделить их очень сложно и часто усилия тратятся повторно на уже решенные задачи. Никлаус Вирт сказал «Программы становятся медленнее быстрее, чем "железо" становится быстрее» и мы часто сталкиваемся с тем, что написать программу заново проще, чем исправлять в ней ошибки.

> Инженерия программного обеспечения (Software engineering)

Приложение инженерии к индустрии программного обеспечения включает архитектуру, исследование, разработку, тестирование, развертывание и поддержку ПО.

Индустрия программного обеспечения превратилась в мощную отрасль промышленности, обросла вспомогательными технологическими практиками, которые позволяют уменьшить влияние ее недостатков, уже приведенных выше и сделать конечный продукт достаточно надежным, чтобы он приносил прибыль, но недостаточно качественным, чтобы можно было выпускать все новые и новые его версии.

«Большинство программ на сегодняшний день подобны египетским пирамидам из миллиона кирпичиков друг на друге и без конструктивной целостности — они просто построены грубой силой и тысячами рабов» // Алан Кей

> Программирование (Programming)

Итак, программирование — это искусство и инженерия решения задач при помощи вычислительной техники. Тут важно отметить, что вычислительная техника очень сильно влияет на то, как мы программируем, диктует то, какие парадигмы и подходы будут работать эффективнее и будут давать результат, доступный нам по ресурсам, затраченным на программирование и по вычислительным ресурсам, требуемым для исполнения созданных программ.

> Кодирование (Coding)

Если выделить из программирования только написание исходного кода программы при помощи определенного синтаксиса (языка), стиля и парадигмы по готовому ТЗ (техническому заданию), то мы называем это кодированием, хоть слово можно считать устаревшим.

Разработка может быть разделена на проектирование и кодирование, и это дает более эффективное приложение сил на долгой дистанции, но часто приходится начинать программировать без ТЗ и без предварительного проектирования. Разработанные таким образом системы называются прототипами, MVP (minimum viable product), пилотными системами или стендами. Их польза заключается в проверке гипотез о полезности для потребителя или экономической эффективности их использования.

Программист не всегда осознает, что он делает, прототип или продукт, и мы получаем прототип, сделанный так добротно, как готовый продукт, или готовый продукт, сделанный как временное решение. Тем не менее, есть энтузиасты, которые любят свою работу, и именно на них держится эта отрасль, противоречивая и полная проблем.

«Большинство хороших программистов делают свою работу не потому, что ожидают оплаты или признания, а потому что получают удовольствие от программирования» // Линус Торвальдс

> Разработчик vs программист

Есть сторонники каждого из названий, часто самоназвание `разработчик` или `программист` связано с особой профессиональной гордостью и даже надменным отношением к сторонникам другого названия. Было бы хорошо разделить эти профессии примерно так же, как разделились профессии водителя и автомеханика. Конечно, автомеханик может говорить, что водители ничего не смыслят в автомобилях, но массово людей возят именно водители. Так же и в ИТ, программист должен концентрироваться на абстракциях и создании программных компонентах, а разработчик — на применении готовых компонентов к задаче, что требует и других знаний и навыков, кроме программирования.

Разницу между программистом и разработчиком можно показать на примере создания информационных систем (ИС). В мире существует потребность массового производства ИС для обеспечения нужд промышленности, транспорта, сферы обслуживания, логистики, торговли, медицины и т.д. Но сейчас информационные системы (ИС) – это дорогое удовольствие и для их разработки нужны высококвалифицированные кадры. ИС, как класс систем, подразумевает базы данных, пользовательские интерфейсы и бизнес-логику. Почти всегда ИС нуждается в интеграции с другими ИС. Таким образом, для разработки ИС нужны знания по СУБД (SQL или noSQL), фронтэнд (формы, UI/UX), бэкэнд (сервер приложений) и API. Поэтому ИС имеют большую стоимость владения, а эксплуатация связана с высокими рисками. Ведь ИС создают универсальные инженеры-программисты, которые пишут для каждой ИС много системного кода с нуля. Если разделить прикладное и системное программирование на две разные специальности и использовать высокоуровневую платформу, которую сделали системные программисты, то мы сможем переиспользовать до 80% кода в разных системах. Прикладные программисты, (т.е. разработчики) смогут тогда сосредоточиться только на задачах, связанных со спецификой предметной области. Это существенно снижает требования к прикладным программистам, а использование принципов свободного программного обеспечения, позволяет объединить усилия по созданию платформы и исключить риски, связанные с владением платформой. Open source лицензии не дают вендорам произвольно менять свою политику по отношению к потребителям и системным интеграторам, потому, что они не имеют блокирующего контроля над платформой и могут быть заменены конкурентами.

Такой подход уже применялся неоднократно и позволил сделать на порядки доступнее бухгалтерское и офисное ПО, разработку веб-сайтов, даже компьютерные игры сейчас не пишут с нуля, а используют платформы, на которых даже начинающие могут быстро показать впечатляющие результаты.

Чтобы внедрить такой подход для ИС, нам нужны новые профессии, новая система подготовки кадров, новый подход к постановки задач и даже заказчик таких ИС должен думать о них совершенно иначе. Существующий спрос должен существенно измениться, вырасти на порядки благодаря тому, что теперь специализированные ИС будут доступны гораздо более широкому кругу потребителей и перестанут быть роскошью.

> Сложность и простота

Давайте же стремиться к тому, чтобы наши программы, были простыми и для потребителя и для нас самих, как людей, которые будут их много раз модифицировать и постоянно сталкиваться с теми решениями, которые мы заложили в них при первичной разработке. А если мы ограничены во времени и вынуждены писать неэффективный или малопонятный код, то следует планировать его переработку, рефакторинг и оптимизацию до того, как мы забудем его структуру и у нас выветрятся все идеи по улучшению. Накопление проблем в коде называется "технический долг" и он приводит не только к тому, что программы становятся менее гибкими и понятными, но и к тому, что наши младшие коллеги, подключаясь к проектам, читают и впитывают не лучшие практики и перенимают наш оверинжиниринг. Простота решения сложных задач, является целью хорошего программиста, скрытие сложности за программными абстракциями — это метод опытного инженера.

«Я всегда мечтал о том, чтобы моим компьютером можно было пользоваться так же легко, как телефоном; моя мечта сбылась: я уже не могу разобраться, как пользоваться моим телефоном» // Бьёрн Страуструп
