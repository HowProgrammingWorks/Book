# 1. Введение

Постоянное переосмысление своей деятельности, даже самой простой, должно сопровождать инженера всю его жизнь. Привычка записывать свои мысли словами и оттачивать формулировки очень помогает в этом. Текст этот появился как мои отрывочные заметки, написанные в разные годы, которые я накапливал и критически вычитывал десятки раз. Часто, я не соглашался с самим собой, перечитывая отрывок после того, как он полежит некоторое время. Поэтому, я доводил текст до того, пока сам не соглашался с написанным после продолжительных периодов выдержки материала. Своей задачей я принял писать как можно более кратко и неоднократно переписывал большие фрагменты, находя, что их можно выразить короче. Структура текста и оглавление начали появляться после первого года преподавания, но на десятом году я решил выложить все материалы не только в виде открытых видеолекций, как делал уже около пяти лет, но и в виде текста. Это позволило участвовать в формировании книги всем желающим из сообщества Метархия, быстро находить опечатки и неточности благодаря читателям, а также многим просто удобнее воспринимать в виде книги. Актуальную версию всегда можно найти на https://github.com/HowProgrammingWorks/Book, она будет дополняться постоянно. Прошу присылать запросы на исправления и дополнения в [issues](https://github.com/HowProgrammingWorks/Book/issues) на английском языке, новые идеи в [discussions](https://github.com/HowProgrammingWorks/Book/discussions) на любом языке, а свои дополнения и исправления оформлять в виде pull-request в репозиторий книги.

Программирование — это искусство и инженерия решения задач при помощи вычислительной техники. Инженерия, потому, что оно призвано извлекать пользу из знаний, а искусство, потому, что знаниями программирование на современном этапе развития, к сожалению, не ограничивается и вынуждено прибегать к интуиции и слабо осмысленному личному опыту. Задача программиста не в нахождении математически верного решения, а в отыскании обобщенного механизма решения, способного нас приводить к нахождению приемлемого решения за ограниченное время в как можно большем классе задач. Другими словами, в нахождении абстрактного класса решений. Не все парадигмы программирования предполагают решение пошаговое, но физическая реализация вычислительной техники и природа человеческого мышления предполагают пошаговость. Сложность в том, что эти действия далеко не всегда сводятся к машинным операциям и вовлекают внешнее взаимодействие с устройствами ввода/вывода и датчиками, а через них, с внешним миром и человеком. Это обстоятельство создает большую неопределенность, которая не позволяет математически строго доказать правильность способа решения всех задач и, тем более, строго вывести такое решение из аксиом, как это характерно для точных наук. Однако, отдельные алгоритмы могут и должны быть выведены аналитически, если они сводимы к чистым функциям. То есть, к функциям, которые в любой момент для определенного набора входных данных однозначно дают один и тот же результат. Чистая функция не имеет истории (памяти или состояния) и не обращается ко внешним устройствам (которые могут такое состояние иметь), может обращаться только к другим чистым функциям. От математики программирование унаследовало возможность находить точные решения аналитически, да и сама вычислительная машина функционирует строго в рамках формального математического аппарата. Но процесс написания программного кода не всегда может быть сведен к формальным процедурам, мы вынуждены принимать решения в условиях большой неопределенности и конструировать программы инженерно. Программист ограничен и временем разработки программы, поэтому, мы сокращаем неопределенность благодаря введению конструктивных ограничений, не являющихся при этом строго выводимыми из задачи и основанных на интуиции и опыте конкретного специалиста. Проще говоря, за неимением оптимального алгоритма, программист может решать задачу любым способом, который дает приемлемые результаты за разумное время, и который может быть реализован за такое время, пока задача еще остается актуальной. В таких условиях мы должны принимать во внимание не только меру приближения решения к оптимальному, но и знания программиста, владение инструментарием и другие ресурсы, имеющиеся в наличии. Ведь даже доступ к знаниям уже готовым программным решениям ограничен авторским правом, правами владения исходным кодом и документацией, соответствующими лицензионными ограничениями, не только на программные продукты, но и на книги, видео, статьи, обучающие материалы, и т.д. Все это существенно усложняет и замедляет развитие отрасли, но со временем доступность знаний необратимо растет, они просачиваются в свободное хождение в сети через популяризаторов, энтузиастов и движение свободного программного обеспечения.
