## 1.7. Обзор парадигм программирования

Математик рассматривает программу как функцию, которую можно декомпозировать (разделить) на более простые функции так, чтобы программа-функция была их суперпозицией. То есть, грубо говоря, программа является сложной формулой, преобразователем данных, когда на вход подаются условия задачи, а на выходе мы получаем решение. Не всякий программист знаком с этой точкой зрения, хоть она и не идеальная, но полезная для переосмысления своей деятельности. Более распространена противоположная точка зрения, которую легко получить из практики программирования. Заключается она в написании программ исходя из представления пользователя, из рисунков экранов пользовательского интерфейса, и из инструментария, языка, платформы и библиотек. В результате, мы получаем не программу-функцию, а большую систему состояний, в которой происходит комбинаторный взрыв переходов и поведение которой непредсказуемо даже для автора, не то что для пользователя. Но нельзя сразу отметать этот, казалось бы, ужасный подход. В нем есть конструктивное зерно, и заключается оно в том, что не все программы возможно в краткие сроки реализовать в функциональной парадигме как преобразователями данных. Тем более что человеческая деятельность вся состоит из шагов и изменения состояний окружающих нас предметов по принципу пошаговых манипуляций ими, а представить ее в виде функций было бы достаточно неестественным для нашего мышления.

> Парадигма задает набор идей и понятий, допущений и ограничений, концепций, принципов, постулатов, приемов и техник программирования для решения задач на вычислительной машине.

В этом разделе мы рассмотрим некоторые из них поверхностно, а далее в книге будет специальная глава с более подробным обсуждением каждой парадигмы. Есть языки, которые поддерживают одну парадигму, а есть мультипарадигменные языки. Мы обратим внимание на разные языки и отличия реализации парадигм в них.

Для человека естественно представление о любом действии как о наборе шагов или алгоритме, это императивный подход. Шаги эти могут быть или линейными, или принятием решения о переходе к другому шагу плана, вместо того, чтобы исполнять действия последовательно. Принятие решения для машины — это операция сравнения, приводящая к ветвлению алгоритма, дающая варианты (обычно два). Действия можно условно разделить на внутренние и внешние. Во внутренних принимают участие только процессор и память, действие выполняется сразу, без ожидания, и имеет определенный результат, который доступен непосредственно на следующем шаге алгоритма. Внешние действия — это обращения к внешним устройствам ввода-вывода (сеть, диски, другие устройства), и они требуют ожидания реакции от устройства, которая придет за время, обычно неизвестное заранее. Мы отправляем управляющий сигнал периферийным устройствам о том, что им нужно что-то сделать и передаем им необходимые для этого данные. Далее у нас есть опять два варианта: или ожидать результата, и это будет называться блокирующим режимом ввода-вывода, или перейти к следующему шагу алгоритма, не дожидаясь результата, и это будет неблокирующий ввод-вывод. Такое разделение вызвано значительной разницей в длительности внутренних и внешних действий. Большинство внешних действий связаны с физическими операциями над внешней средой. Например, передача данных по беспроводной или проводной сети, запись или чтение с физического носителя, взаимодействие с датчикоом, реле или приводом. Такие операции часто имеют не цифровую, а аналоговую природу, поэтому требуется дополнительное преобразование данных, ожидание переходного процесса, ожидание нужного показания датчика или сигнала от устройства и т.д. Устройства ввода-вывода часто имеют свой контроллер, в котором выполняется отдельный поток операций, а взаимодействие между центральным процессором и устройствами ввода-вывода также требует согласования, что занимает время и может закончиться неудачно.

> Парадигма предлагает модель решения задач, определенный стиль, шаблоны (примеры хороших и плохих решений) применяемых для написания программного кода.
