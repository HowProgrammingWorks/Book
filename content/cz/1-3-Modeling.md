## 1.3. Modelování: abstrakce a opětovné použití

Srdcem programování je modelování, tedy vytvoření modelu řešení problému neboli modelu objektů a procesů v paměti počítačů. Programovací jazyky poskytují syntaxi pro navrhování omezení při vytváření modelů. Jakákoli konstrukce a struktura navržená pro rozšíření funkčnosti a zavedená do modelu vede k dalším omezením. Zvýšení úrovně abstrakce může naopak některá omezení odstranit a snížit složitost modelu a programového kódu, který tento model vyjadřuje. Neustále balancujeme mezi rozšiřováním funkcí a jejich sbalováním do zobecněného modelu. Tento proces může a měl by být iterativní.

Člověk překvapivě dokáže úspěšně řešit problémy, jejichž složitost přesahuje možnosti jeho paměti a myšlení, pomocí sestavení modelů a abstrakcí. Přesnost těchto modelů určuje jejich užitečnost pro rozhodování a rozvoj kontrolních akcí. Model je vždy nepřesný a odráží pouze malou část reality: jednu nebo více jejích stran či aspektů. V omezených podmínkách použití však může být model shodný s reálným objektem předmětné oblasti. Existují fyzikální, matematické, simulační a další modely, ale nás budou zajímat především informační a algoritmické modely.

Abstrakce je technika zobecnění, která redukuje mnoho různých, ale podobných případů na jediný model. Zajímají nás datové abstrakce a abstraktní algoritmy. Nejjednoduššími příklady abstrakce v algoritmech jsou cykly (iterativní zobecnění) a funkce (procedury a podprogramy). Pomocí cyklu můžeme popsat mnoho iterací jedním blokem příkazů za předpokladu jeho vícenásobného opakování, s různými hodnotami proměnných. Funkce se taky mnohokrát opakují s různými argumenty. Příkladem abstrakce dat jsou pole, asociativní pole, seznamy, množiny atd. V aplikacích je potřeba abstrakce kombinovat ve vrstvách, nazýváme je abstraktní vrstvy. Nízkoúrovňové abstrakce jsou zabudovány do programovacího jazyka (proměnné, funkce, pole, události). Abstrakce vyšší úrovně jsou obsaženy ve frameworkech, runtimech, standardních knihovnách a externích knihovnách, nebo si je můžete vytvořit sami z jednoduchých abstrakcí. Abstrakce se tak nazývají, protože řeší zobecněné abstraktní úlohy nesouvisející s předmětnou oblastí.

Budování abstraktních vrstev je téměř nejdůležitější programovací úkol, jehož úspěšné řešení určuje takové vlastnosti softwarového řešení, jako je flexibilita přizpůsobení, snadná modifikace, schopnost integrace s jinými systémy a životnost řešení. Všechny vrstvy, které nejsou vázány na předmět a konkrétní aplikované úkoly, se budou nazývat systémové vrstvy. Nad systémovými vrstvami programátor staví aplikační vrstvy, jejichž abstrakce se naopak snižuje, univerzálnost klesá a aplikace se stává specifičtější, vázána na konkrétní úkoly.

Abstrakce různých úrovní mohou být umístěny jak v jednom adresním prostoru (jeden proces nebo jedna aplikace), tak i v různých. Je možné je od sebe oddělit a zavést mezi nimi interakci pomocí programovacích rozhraní, modularity, komponentního přístupu a jednoduše silou vůle, vyhnout se přímým voláním ze středu jedné softwarové komponenty doprostřed jiné, pokud programovací jazyk nebo platforma se nestará o to, aby takové schopnosti zabránily. To by mělo být provedeno i v rámci jednoho procesu, kde by jakékoli funkce, komponenty a moduly mohly být přístupné z jakéhokoli jiného, i když logicky patří do různých vrstev. Důvodem je potřeba snížit vzájemnou závislost mezi vrstvami a softwarovými komponentami, což umožňuje, aby byly zaměnitelné, znovu použitelné a mohly být vyvíjeny samostatně. Zároveň je nutné zvýšit konektivitu v rámci vrstev, komponent a modulů, což zajišťuje růst výkonu kódu, jeho snadné čtení, pochopení a úpravy. Pokud se dokážeme vyhnout propojenosti mezi různými úrovněmi abstrakce a použít dekompozici, abychom zajistili, že jeden modul může být vždy zcela pokryt pozorností jednoho inženýra, pak se vývojový proces stane škálovatelným, řiditelným a předvídatelnějším. Podobná myšlenka je základem architektury mikroslužeb, ale obecnější princip platí pro jakýkoli systém, a nezáleží na tom, zda se jedná o samostatně běžící mikroslužby nebo moduly běžící ve stejném procesu.

Je třeba poznamenat, že čím lépe je systém distribuován, tím lépe je centralizován. Protože řešení problémů v takových systémech probíhá na adekvátních úrovních, kde je již dostatek informací pro rozhodování, zpracování a získávání výsledků, nedochází k rigidnímu propojení modelů různých úrovní abstrakce. Díky tomuto přístupu se vyhneme zbytečným eskalacím úkolu na vyšších úrovních, je zabráněno "přehřívání" rozhodovacích uzlů, minimalizován přenos dat a zvýšena provozní rychlost.
