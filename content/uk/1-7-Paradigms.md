## 1.7. Огляд парадигм програмування

Математика розглядає програму, як функцію, яку можна декомпозувати (розділити) на більш прості функції так, щоб програма-функція була їх суперпозицією. Тобто, грубо кажучи, програма є складною формулою, перетворювачем даних, коли на вхід подаються умови завдання, а на виході ми отримуємо рішення. Не всякий програміст знайомий із цією точкою зору, хоч вона й не ідеальна, але корисна для переосмислення своєї діяльності. Більш поширена протилежна точка зору, яку легко одержати з практики програмування. Полягає вона в написанні програм виходячи з уявлення користувача, з малюнків екранів інтерфейсу користувача, і з інструментарію, мови, платформи і бібліотек. В результаті ми отримуємо не програму-функцію, а велику систему станів, в якій відбувається комбінаторний вибух переходів і поведінка якої непередбачувана навіть для автора, не те що для користувача. Але не можна відразу відкидати цей, здавалося б, жахливий підхід. У ньому є конструктивне зерно, і полягає воно в тому, що не всі програми можна за короткий термін реалізувати у функціональній парадигмі, як перетворювачі даних. Тим більше, що людська діяльність вся складається з кроків і зміни станів навколишніх предметів за принципом покрокових маніпуляцій ними, а уявити її у вигляді функцій було б досить неприродним для нашого мислення.

Набір базових ідей, використовуваних інженером для побудови моделей, абстракцій та програмних систем, називається парадигмою. У цьому розділі ми розглянемо деякі з них поверхнево, а далі у книзі буде спеціальний розділ з більш детальним обговоренням кожної парадигми. Існують мови, які підтримують одну парадигму, а є мультипарадигмові мови. Ми звернемо увагу на різні мови та відмінності реалізації парадигм у них.

Для людини природно уявлення про будь-яку дію, як про набір кроків або алгоритм, це імперативний підхід. Ці кроки можуть бути або лінійними або прийняттям рішення про перехід до іншого кроку плану, замість того, щоб виконувати дії послідовно. Прийняття рішення для машини це операція, порівняння, що веде до розгалуження алгоритму, що дає варіанти (зазвичай два). Події можна умовно поділити на внутрішні та зовнішні. У внутрішніх беруть участь лише процесор та пам'ять, дія виконується відразу, без очікування, і має певний результат, який доступний безпосередньо на наступному етапі алгоритму. Зовнішні дії - це звернення до зовнішніх пристроїв введення-виводу (мережа, диски, інші пристрої), і вони вимагають очікування реакції від пристрою, яка прийде за час, зазвичай невідомий заздалегідь. Ми надсилаємо керуючий сигнал периферійним пристроям про те, що їм потрібно щось зробити і передаємо їм потрібні для цього дані. Далі у нас знову є два варіанти, або чекати результату, і це буде називатися блокуючим режимом вводу-виведення або перейти до наступного кроку алгоритму, не чекаючи результату, і це буде неблокуючий ввід-вивід. Такий поділ спричинено значною різницею у тривалості внутрішніх та зовнішніх дій. Більшість зовнішніх дій пов'язані з фізичними операціями над зовнішнім середовищем. Наприклад, передача даних через бездротову або провідну мережу, запис або читання з фізичного носія, взаємодія з датчиком, реле або приводом. Такі операції часто мають не цифрову, а аналогову природу, тому потрібно додаткове перетворення даних, очікування перехідного процесу, очікування потрібного показання датчика або сигналу від пристрою і т.д. Пристрої введення-виводу часто мають свій контролер, в якому виконується окремий потік операцій, а взаємодія між центральним процесором та пристроями введення-виводу також вимагає узгодження, що займає час і може закінчитися невдало.
