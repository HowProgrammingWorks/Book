## 1.4. Алгоритм, программа, синтаксис, мова

Є багато термінів, пов'язаних із програмуванням. Для визначеності нам слід з'ясувати різницю між ними. Краще зосередитися на неформальному розумінні, ніж формальному визначенні. Найстарішим поняттям тут є алгоритм, який ми пам'ятаємо зі шкільного курсу математики. Наприклад, алгоритм Евкліда знаходження найбільшого спільного дільника двох цілих чисел.

Алгоритм (Algorithm)

Алгоритм це ще не програма, це ідея вирішення завдання, описана формально. Так, щоб вона була зрозуміла іншим, вона перевіряється та реалізується. Алгоритм не можна запустити, його можна перетворити на код якоюсь мовою програмування. Алгоритм містить опис операцій і може бути записаний різними способами: формулою, блок-схемою, списком дій, людською мовою. Він завжди обмежений конкретним класом завдань, що він вирішує за кінцевий час. Часто ми можемо спростити та оптимізувати алгоритм, звузивши клас завдань. Наприклад, переходячи від обчислення суми цілих і дробових чисел до обчислення суми лише цілих, ми можемо зробити ефективнішу реалізацію. Можна і розширити клас задач для цього прикладу, дозволивши подавати на вхід ще й рядкові подання чисел. Це зробить алгоритм більш універсальним, але менш ефективним. Ми маємо вибирати, що саме ми оптимізуємо. В даному випадку краще розділити алгоритм на два, один наводитиме всі числа до одного типу даних, а другий складатиме.

Приклад реалізації алгоритму НОД (GCD)

На JavaScript алгоритм Евкліда, для знаходження НОД (загальної міри чи найбільшого спільного дільника) можна написати так:

```js
const gcd = (a, b) => {
  if (b === 0) return a;
  return gcd(b, a % b);
};
```

Або навіть коротше, але стане не менш зрозумілим, якщо ви порівняєте два ці варіанти і простежте які конструкції замінені:

```js
const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
```

Цей простий алгоритм є рекурсивним, тобто звертається до себе для обчислення наступного кроку і передбачає вихід, коли b доходить до 0. Для алгоритмів ми можемо визначати обчислювальну складність, класифікувати їх за ресурсами процесорного часу та пам'яті, необхідним для вирішення задачі.

Програма (Program)

У попередньому прикладі ми мали справу з функцією, це частина програми, але щоб вона запрацювала, її потрібно викликати та передати їй дані. Програмний код та дані, об'єднані в одне ціле – це і є програма. Ніклаус Вірт, автор багатьох мов, у тому числі і Pascal, має книгу «Алгоритми + Структури даних = Програми». Її назва схопила дуже важливу істину, яка глибоко відобразилася не тільки у світогляді читачів, а й у назвах курсів у провідних ВНЗ, і навіть на співбесідах, коли випробуваного просять сконцентруватися саме на цих двох речах. За перші 50 років існування індустрії програмного забезпечення виявилося, що структури даних не менш важливі, ніж алгоритми. Більше того, багато відомих програмістів роблять на них основну ставку, наприклад, відома цитата Лінуса Торвальдса: «Погані програмісти турбуються про код. Хороші програмісти турбуються про структури даних та зв'язки між ними». Справа в тому, що вибір структур даних багато в чому визначає те, яким буде алгоритм, обмежує його в рамках обчислювальної складності та семантики завдання, яке програміст розуміє через дані, розкладені в пам'яті, набагато краще, ніж через послідовність операцій.

Ерік Реймонд висловив це так: «Розумні структури даних і тупий код працюють набагато краще, ніж навпаки».

Код дозволяє порозумітися

Однак той самий Лінус Торвальдс сказав нам «Бовтовня нічого не варта. Покажіть мені код». Це зовсім не суперечить сказаному вище. Я думаю, що він мав на увазі те, що програмний код не допускає двозначності. Це універсальна мова, яка дозволяє програмістам знаходити спільну мову навіть тоді, коли природні мови через свою багатозначність не дозволяють точно зрозуміти один одного, можна зробити це просто поглянувши на код.

Інженерія (Engineering)

Вилучення практичної користі з наявних ресурсів за допомогою науки, техніки, різних методик, організаційної структури, прийомів та знань – це наступний рівень — інженерія.

Я пам'ятаю, що в перші роки вивчення програмування для мене вже було важливо, щоб код використовувався людьми, покращував їхнє життя і жив довго. Олімпіадні завдання здавались мені нецікавими, навчальні завдання надто надуманими, хотілося сконцентруватися на тому, що люди запускатимуть на своїх комп'ютерах щодня: програми баз даних, форми та таблиці, мережеві та комунікаційні програми, програми, що керують апаратурою, працюють з датчиками, та безліч інструментів для програмістів.

Так само, як і в інших інженерних галузях, у програмуванні дуже важлива користь для людини, а не правильність або стрункість концепції. Інженерія покликана використовувати наукові досягнення, а в тих місцях, де наукових знань, що є на сьогодні, недостатньо, інженерія застосовує інтуїцію, інженерну культуру, метод спроб і помилок,
