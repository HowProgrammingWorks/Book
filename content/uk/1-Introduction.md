# 1. Вступ

Постійне переосмислення своєї діяльності, навіть найпростішої, має супроводжувати інженера все його життя. Звичка записувати свої думки словами та відточувати формулювання дуже допомагає у цьому. Текст цей з'явився як мої уривчасті нотатки, написані в різні роки, які я накопичував і критично вичитував десятки разів. Часто, я не погоджувався з собою, перечитуючи уривок після того, як він полежить деякий час. Тому я доводив текст до того, поки сам не погоджувався з написаним після тривалих періодів витримки матеріалу. Своїм завданням я прийняв писати якомога коротше і неодноразово переписував великі фрагменти, знаходячи, що їх можна виразити коротше. Це дозволило брати участь у формуванні книги всім охочим із спільноти Метархія, швидко знаходити помилки та неточності завдяки читачам, а також багатьом просто зручніше сприймати у вигляді книги. Актуальну версію завжди можна знайти на https://github.com/HowProgrammingWorks/Book, вона доповнюватиметься постійно. Прошу надсилати запити на виправлення та доповнення до [issues](https://github.com/HowProgrammingWorks/Book/issues) англійською мовою, нові ідеї у [discussions](https://github.com/HowProgrammingWorks/Book/discussions) будь-якою мовою, а свої доповнення та виправлення оформляти у вигляді pull-request у репозиторій книги.

Програмування – це мистецтво та інженерія розв'язання задач за допомогою обчислювальної техніки. Інженерія, тому що воно покликане отримувати користь із знань, а мистецтво, тому що знаннями програмування на сучасному етапі розвитку, на жаль, не обмежується і змушене вдаватися до інтуїції та слабко осмисленого особистого досвіду. Завдання програміста не у знаходженні математично вірного рішення, а у відшуканні узагальненого механізму рішення, здатного нас приводити до знаходження прийнятного рішення за обмежений час у якомога більшому класі завдань. Іншими словами, у знаходженні абстрактного класу рішень. Не всі парадигми програмування припускають рішення покрокове, але фізична реалізація обчислювальної техніки та природа людського мислення передбачають покроковість. Складність у цьому, що ці дії далеко не завжди зводяться до машинних операцій і залучають зовнішню взаємодію з пристроями введення/виводу і датчиками, а через них, із зовнішнім світом і людиною. Ця обставина створює велику невизначеність, яка не дозволяє математично суворо довести правильність способу вирішення всіх завдань і, тим більше, суворо вивести таке рішення з аксіом, як це характерно для точних наук. Однак, окремі алгоритми можуть бути виведені аналітично, якщо вони зводяться до чистих функцій. Тобто, до функцій, які у будь-який момент для певного набору вхідних даних однозначно дають однаковий результат. Чиста функція не має історії (пам'яті або стану) і не звертається до зовнішніх пристроїв (які можуть мати такий стан), може звертатися тільки до інших чистих функцій. Від математики програмування успадкувало можливість шукати точні рішення аналітично, та й сама обчислювальна машина функціонує строго в рамках формального математичного апарату. Але процес написання програмного коду не завжди може бути зведений до формальних процедур, ми змушені приймати рішення в умовах великої невизначеності та конструювати програми інженерно. Програміст обмежений і часом розробки програми, тому ми зменшуємо невизначеність завдяки введенню конструктивних обмежень, які не є суворо виведеними із завдання і засновані на інтуїції та досвіді конкретного спеціаліста. Простіше кажучи, через відсутність оптимального алгоритму, програміст може вирішувати завдання будь-яким способом, який дає прийнятні результати за розумний час, і який може бути реалізований за такий час, поки завдання ще залишається актуальним. У таких умовах ми повинні брати до уваги не тільки міру наближення рішення до оптимального, а й знання програміста, володіння інструментарієм та інші наявні ресурси. Адже навіть доступ до знань вже готових програмних рішень обмежений авторським правом, правами володіння вихідним кодом та документацією, що відповідають ліцензійними обмеженнями, не тільки на програмні продукти, а й на книги, відео, статті, навчальні матеріали тощо. Все це суттєво ускладнює та уповільнює розвиток галузі, але згодом доступність знань незворотно зростає, вони просочуються у вільне ходіння в мережі через популяризаторів, ентузіастів та рух вільного програмного забезпечення.
