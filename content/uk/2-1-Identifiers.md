## 2.1. Значення, ідентифікатор, змінна та константа, літерал, присвоєння

> Ідентифікатор (identifier)

Найважливіше у програмуванні — це давати зрозумілі імена ідентифікаторам (змінним, константам, параметрам, функціям, класам і т.д.) і розташовувати їх в програмі так, щоб вони були видні у потрібних місцях. При цьому моємо намагатися скоротити їх область видимості. Ідентифікатори можуть бути глобальними, оголошеними у файлі або імпортованими з інших модулів програми.

Є різні конвенції (домовленості) про іменування, традиції мов і парадигм, але у всіх них імена мають бути _консистентні_ (однотипні) і _зрозумілі_ навіть для тих, хто цей код не писав. Приклади хороших імен ідентифікаторів:

- Глобальні змінні: `MAX_PURCHASE`, `REQUEST_TIMEOUT`, `ERROR_CODES`;
- Колекції: `prices`, `goods`, `boughtItems`;
- Окремі значення: `amount`, `groupName`, `total`;
- Функції: `calculateSubtotal`, `calculateTotal`, `validateExpenses`;

Приклади поганих імен розглянемо докладніше:

- Глобальна константа `Maximum` - не зрозуміло, максимум чого, без другого слова константа не може бути глобальною; порушені конвенції використання малих і великих букв, замість `camelCase` тут використаний `PascalCase` і таку константу складно помітити при читанні коду;
- Таймаут запитів `request_timeout` - порушені конвенції;
- Коди помилок `ERCODE` - складно читається; незрозуміло, що це колекція кодів, а не один код;
- Масив цін `numbers` - не потрібно називати масиви іменами типів даних, які в них знаходяться, з цієї назви дуже складно зрозуміти, що там ціни;
- Масив товарів `arrayOfGoods` - не додавайте назви структур даних до імен змінних;
- Надто довге ім'я для колекції товарів: `orderItemsInShopBasket`;
- Неочевидне скорочення `amt`;
- Крім явного порушення концепцій `grp_N` ще й вводить в оману, це погане скорочення, не потрібно заощаджувати на літерах до такого ступеня;
- Не називайте змінні транслітом, як `itogo2` і не використовуйте цифри для іменування змінних зі схожим змістом, спробуйте врахувати відтінки сенсу, наприклад: `total` та `subtotal`;
- Якщо структура містить два значення, як `totalAndSubtotal`, то потрібно назвати її таким словом, яке узагальнює їх, наприклад `order`;
- Крім порушення конвенцій `BuyerCalculations` ще й дуже не точний, не зрозуміло, які саме обчислення;
- Короткі скорочення типу `VE` - абсолютно неприйнятні як імена, якщо тільки це не загальноприйняті `i` та `j` для циклів або, `x` і `y` для координат і ще кілька подібних випадків.

> Оголошення та присвоєння (assignment)

```js
let migrationYear = 622;
```

Цей запис на JavaScript і тут `migrationYear` — ім'я ідентифікатора, `=` це оператор присвоєння, `622` — значення, а `let` означає, що значення може бути переприсвоєно, тобто, змінено.

На C і C++ аналогічний код виглядатиме так:

```c
int migrationYear = 622; // тут тип int представляет целое число
```

У Python, як і JavaScript, оператор присвоєння не вимагає вказувати тип, він визначається з типу літералу. А при присвоєнні ми не можемо заборонити переприсвоєння ідентифікатору іншого значення.

```py
migrationYear = 622
```

Операція присвоєння у багатьох мовах повертає значення (має поведінку виразу). Таким чином, можна написати:

```js
let year;
const migration = (year = 622); // теперь оба идентификатора
console.log({ migration, year }); // имеют значение 622
```

Але такий синтаксис погано читається і може ввести в оману, як і завдання кількох ідентифікаторів через кому:

```
let year = 622, migration = 'Hijrah', i, counter = 0;
```

Економія в коді це добре, але не заощаджуйте літери та рядки за рахунок читабельності коду. Натомість краще написати:

```js
let year = 622;
let migration = 'Hijrah';
let i;
let counter = 0;
```

А ще краще відразу вирішити, які ідентифікатори не змінюватимуть свого значення і задати їх через `const`:

```js
const year = 622;
const migration = 'Hijrah';
let i;
let counter = 0;
```

> Змінні та константи

У повсякденному спілкуванні навіть професіонали часто плутають поняття, називаючи константу змінною, адже слово ідентифікатор занадто довге, а слово константа занадто багатозначне. Це трапляється з локальними константами, які ми називаємо у стилі `lowerCamel`, наприклад, усередині функцій. Їх значення може бути різним за різних викликів функції, а є глобальні значення, яких однакове у будь-якому місці програми або файлу, і ми називаємо їх у стилі `UPPER_SNAKE`.

```js
const WATCH_TIMEOUT = 5000; // Глобальная константа
```

```js
const cityName = 'Beijing'; // Локальная константа
```

```js
let distance = 0; // Переменная
```

Ми можемо змінювати значення змінної на відміну від константи, а для деяких мов, як JavaScript і Python, можемо змінювати і тип, але це сильно погіршуватиме читаність коду, наприклад:

```js
let migration = 'Hijrah'; // используем переменную первый раз
console.log(migration); // вывод строки
migration = 622; // используем повторно для других целей
console.log(migration); // вывод числа
```

> Літерал (Literal) — запис значення коду програми

Ідентифікатори зв'язуються зі своїми значеннями в пам'яті під час роботи програми, але під час написання коду ми іноді хочемо задавати значення синтаксично (тобто записувати їх символами в правилах конкретної мови програмування). Наприклад: літерал числа та рядки, літерал об'єкта та масиву, навіть літерал функції та класу (але їх ми побачимо в наступних розділах). У різних мовах різні правила запису літералів, але вони частково збігаються і зазвичай їх легко прочитати. Літерали можуть задавати не тільки значення, а тип та систему числення за допомогою префіксів та суфіксів. Давайте подивимося приклади:

- Рядок `it's`: в одинарних лапках `'it\'s'`, тут символ бекслеш `\` дозволяє використовувати лапку всередині рядка; у подвійних `"it's"`, тут `\` не потрібен, але може використовуватися для подвійної лапки всередині рядка та інших символів;
- Ціле число `255` можна записати, як `0xFF` у шістнадцятковій системі; `0o377` у вісімковій; а ось запис `0377` це стара форма, вона не підтримується в Python починаючи з 3 версії, а у JavaScript працює, але погано читається; `0b11111111` у бінарному записі; літерал `255n` із суфіксом `n` у JavaScript створює значення типу BigInt; а `255u`; `255l`, `255ul` у C++ та низці інших мов, де суфікс `u` (unsigned) і задає беззнаковий тип, а суфікс `l` (long) задає довге число;
- Дробове число `1.618` записується: `1.618`; в C++ і Java `1.618f` число з плаваючою точкою; і `1.618d` число з подвійною точністю, а `1618e-3` в експоненційній формі;
- Число `-12000`, крім звичайного запису, може бути записано: `-12000n`; `-1.2e4`; `-12e3`; `-12e3f`; `-1.2e4d`; тут символи `n`, `f` та `d` позначають тип, а `e` експоненційну форму; у різних мовах підтримуються різні форми запису;
- Булеві літерали: `true` та `false`;
- Літерал масиву: `[1, 2, 3]` у JavaScript та Python; в C і C++, Java, C# `{ 1, 2, 3, 4 }`;
- Літерал словника: `{ 'uno': 1, 'due': 2, 'tre': 3 }` у Python; і літерал об'єкту `{ uno: 1, due: 2, tre: 3 }` у JavaScript;

Ця книга не є посібником з якоїсь мови, а особливості конкретної мови можна дізнатися з її специфікації, підручника або прикладів коду, яких тут достатньо, щоб освоїти запис усіх необхідних літералів JavaScript і Python.

> Приклад програми

Тут багато конструкцій знайомі, але є й нові (функція, цикл, умова), вони будуть докладніше розглянуті в наступних розділах, хоча їхнє просте використання не складно прочитати і зрозуміти вже зараз.

```js
'use strict';

const MAX_PURCHASE = 2000; // Глобальна константа

// Функція обчислення суми покупок із масиву цін
// prices - параметр (масив цін)
const calculateTotal = (prices) => {
  // Задаємо змінну з початковим значенням
  let amount = 0; // Перебираємо елементи масиву у циклі
  for (const price of prices) {
    // локальна константа price не змінюється у циклі
    // на кожному проході додаємо до суми
    amount += price;
  }
  return amount; // Повертаємо суму з функції
};

// Задаємо масив цін товарів
const purchase = [1500, 100, 10, 50];
// Викликаємо функцію обчислення суми та передаємо їй аргумент
// З функції значення аргументу буде доступним через параметр
const total = calculateTotal(purchase);
// Результат записуємо в локальну константу
// Якщо сума не перевищила максимальної, то виводимо її
if (total <= MAX_PURCHASE) {
  console.log({ total }); // Виводить: {total: 1660}
}
```
