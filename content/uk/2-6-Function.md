## 2.6. Функція вищого порядку, чиста функція, побічні ефекти

Оголошення функції (Function definition) — у `JavaScript` це спосіб оголошення функції, який видимий з будь-якого місця в лексичному контексті, в якому оголошена функція, приклад:

```js
function sum(a, b) {
  return a + b;
}
```

Функціональний вираз (Function expression) — зв'язування функції з ідентифікатором за допомогою присвоєння, при якому значення буде доступне через ідентифікатор не в усьому лексичному контексті, а тільки після місця присвоєння. Має кілька синтаксичних варіантів:

Функціональний вираз з іменованою функцією (Named function expression):

```js
const sum = function sum(a, b) {
  return a + b;
};
```

Анонімний функціональний вираз (Anonymous function expression):

```js
const sum = function (a, b) {
  return a + b;
};
```

Стрілкова або лямбда-функція (Arrow, Lambda function):

```js
const sum = (a, b) => {
  return a + b;
};
```

Лямбда-вираз, Функція-стрілка з виразом як тілом (Lambda expression, Arrow function):

```js
const sum = (a, b) => a + b;
```

> Чиста функція (Pure Function) — детермінована функція без побічних ефектів.

Чиста функція - функція, що обчислює результат тільки на основі аргументів, не має стану і не звертається до операцій введення-виведення. Результат такої функції завжди детермінований і без побічних ефектів (див. побічний ефект).

> Замикання (Closure) — функція, пов'язана з лексичним оточенням у момент свого створення.

Якщо повернути функцію `g` з функції `f`, то `g` буде бачити контекст функції `f`, так само, як і свої аргументи. Якщо `f` повертає `g`, то кажуть, що екземпляр `g` замкнув контекст `f`. Замикання — це спосіб, що дозволяє пов'язати функцію з контекстом (з даними або змінними контексту). Замикання дозволяє створити ефект, аналогічний стану об'єкта (набору його властивостей) в ООП. Властивості пов'язані з методами через об'єкт, по суті об'єкт в ООП сам є контекстом зв'язування. Замикання також породжує подібний контекст, але на основі функцій першого класу і лексичного контексту, а не об'єктного.

За допомогою замикання можна реалізувати функціональне наслідування.

Приклади:

```js
const sum = (a) => (b) => a + b;

const hash =
  (data = {}) =>
  (key, value) => ((data[key] = value), data);
```

> Суперпозиція (Superposition) — об'єднання виклику функцій у вирази таким чином, що результат одних функцій стає аргументами інших функцій.

```js
const expr2 = sum(
  pow(mul(5, 8), 2),
  div(inc(sqrt(20)), log(2, 7))
);
```

> Композиція (Composition) — створення нової функції об'єднанням простіших.

```js
const compose = (f1, f2) => (x) => f2(f1(x));
```

```js
// prettier-ignore
const compose = (...funcs) => (...args) =>
  funcs.reduce((args, fn) => [fn(...args)], args);
```

> Часткове застосування (Partial application)

```js
// prettier-ignore
const partial = (fn, x) => (...args) => fn(x, ...args);
```

> Каррування (Currying)

```js
const result = curry((a, b, c) => a + b + c)(1, 2)(3);
```

> Побічні ефекти (Side effects)

> Функція вищого порядку (Higher-order Function)

1. Якщо функція передається в іншу функцію як аргумент, то це колбек.
2. Якщо функція повертається як результат, то це фабрика функцій на замиканнях.
3. Якщо функція, що повертається, має ту ж семантику, що й отримана в аргументах, але з додатковою (розширеною) поведінкою, то це функція-обгортка.
4. Рідко буває, що функція, що повертається, не пов'язана з функцією з аргументів, або пов'язана не прямо, а також має іншу семантику і функцією-обгорткою вона не є.
5. Якщо на виході клас або функція-конструктор, то це фабрики класів і прототипів відповідно.

> Функція-обгортка (Wrapper)

Функція, яка обгортає іншу функцію (іноді об'єкт, інтерфейс або функціональний об'єкт), додаючи їй додаткову поведінку. Можна обгорнути цілий API інтерфейс і навіть асинхронну функцію разом з колбеками (якщо відомий контракт).

```js
const sum = (a, b) => a + b;

console.log(`Add nums:    ${sum(5, 2)}`);
console.log(`Add float:   ${sum(5.1, 2.3)}`);
console.log(`Concatenate: ${sum('5', '2')}`);
console.log(`Subtraction: ${sum(5, -2)}`);
```
