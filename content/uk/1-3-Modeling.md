## 1.3. Моделювання: абстракції та повторне використання

В основі будь-якого програмування лежить моделювання, тобто створення моделі розв'язання задачі або моделі об'єктів і процесів у пам'яті машини. Мови програмування надають синтаксиси для конструювання обмежень під час створення моделей. Будь-яка конструкція та структура, покликана розширити функціональність та введена в модель, призводить до додаткових обмежень. Підвищення рівня абстракції, навпаки, може знімати частину обмежень і зменшувати складність моделі і коду програми, що виражає цю модель. Ми постійно балансуємо між розширенням функцій і згортанням їх у більш узагальнену модель. Цей процес може та повинен бути багаторазово ітеративним.

Дивно, але людина здатна успішно вирішувати завдання, складність яких перевищує можливості її пам'яті та мислення, за допомогою побудови моделей та абстракцій. Точність цих моделей визначає їх користь для прийняття рішень та вироблення керуючих впливів. Модель завжди не точна і відображає лише малу частину реальності, одну чи кілька її сторін чи аспектів. Однак, в обмежених умовах використання, модель може бути невідмінною від реального об'єкта предметної області. Є фізичні, математичні, імітаційні та інші моделі, але нас цікавитимуть насамперед інформаційні та алгоритмічні моделі.

Абстракція, це спосіб узагальнення, що зводить безліч різних, але схожих між собою випадків до однієї моделі. Нас цікавлять абстракції даних та абстрактні алгоритми. Найпростіші приклади абстракції в алгоритмах, це цикли (ітераційне узагальнення) та функції (процедури та підпрограми). За допомогою циклу ми можемо описати багато ітерацій одним блоком команд, припускаючи його повторюваність кілька разів, з різними значеннями змінних. Функції також повторюються багато разів з різними аргументами. Приклади абстракції даних, це масиви, асоціативні масиви, списки, множини тощо. У застосунках абстракції потрібно поєднувати в рівні – шари абстракцій. Низькорівневі абстракції вбудовані у мову програмування (змінні, функції, масиви, події). Абстракції більш високого рівня містяться у програмних платформах, рантаймах, стандартних бібліотеках, та зовнішніх бібліотеках або їх можна побудувати самостійно із простих абстракцій. Абстракції так називаються тому, що вирішують абстрактні узагальнені завдання загального призначення, не пов'язані з предметною областю.

Побудова шарів абстракцій це чи не найважливіша задача програмування від успішного вирішення якої залежать такі характеристики програмного рішення, як гнучкість налаштування, простота модифікації, здатність до інтеграції з іншими системами та період життя рішення. Всі шари, які не прив'язані до предметної області та конкретних прикладних завдань, ми називатимемо системними. Над системними шарами програміст надбудовує прикладні шари, абстракція яких навпаки знижується, універсальність зменшується та конкретизується застосування, прив'язуючись до конкретних завдань.

Абстракції різних рівнів можуть бути як в одному адресному просторі (одному процесі або одному застосунку), так і в різних. Відокремити їх один від одного і здійснити взаємодію між ними можна за допомогою програмних інтерфейсів, модульності, компонентного підходу і просто зусиллям волі, уникаючи прямих викликів із середини одного програмного компонента в середину іншого, якщо мова програмування або платформа не дбають про запобігання такій можливості. Так слід чинити навіть усередині одного процесу, де можна було б звертатися до будь-яких функцій, компонентів та модулів з будь-яких інших, навіть якщо вони логічно відносяться до різних шарів. Причина цього в необхідності знизити пов'язаність шарів та програмних компонентів, забезпечивши їх взаємозамінність, повторне використання та роблячи можливою їх роздільну розробку. Одночасно потрібно підвищувати зв'язність усередині шарів, компонентів та модулів, що забезпечує зростання продуктивності коду, простоту його читання, розуміння та модифікації. Якщо ж нам вдасться уникати зв'язаності між різними рівнями абстракцій, і за допомогою декомпозиції домогтися того, щоб один модуль завжди міг бути повністю охоплений увагою одного інженера, процес розробки стає масштабованим, керованим і більш передбачуваним. Подібна ідея покладена в основу архітектури мікросервісів, але більш загальний принцип застосовується для будь-яких систем, і не важливо, чи це будуть незалежно запущені мікросервіси або модулі, запущені в одному процесі.

Слід зазначити, що чим краще система розподілена, тим краще вона централізована. Тому, як вирішення завдань у таких системах знаходяться на адекватних рівнях, де вже достатньо інформації для прийняття рішень, обробки та отримання результату, відсутня жорстка зв'язаність моделей різного рівня абстракції. При такому підході немає зайвих ескалацій завдання на верхні рівні, уникаються “перегріви” вузлів прийняття рішень, мінімізована передача даних і підвищена оперативна швидкодія.
